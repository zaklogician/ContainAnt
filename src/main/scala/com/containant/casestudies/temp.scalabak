package com.containant.casestudies

/** The dependency injection problem can encode various combinatorial
 *  optimization problems easily and intuitively.
 *
 *  The following encodes the subset-sum problem.
 *
 *  The test instances are from
 *  https://people.sc.fsu.edu/~jburkardt/datasets/subset_sum/subset_sum.html
 */

import com.containant._
import com.containant.heuristics._

object CS2SubsetSum {
  //////////////////////////////////////////////////////////////////////
  // Configuration
  val _seed: Int = 0xDEADBEEF
  val _runs: Int = 100
  // target fitness fn. evaluations ~ 100 for comparison with SMAC, which often
  //                                  terminates under 100 on this prob.
  
  object Hmma extends AntHeuristic {
    override val _evaporationRate: Double = 0.4
    override val _iterations: Int = 1000
    override val _antNumber: Int = 3
    override val _minimumFraction: Double = 0.10
    override val _recursionDepth: Int = 10
    override val RNG: java.util.Random = new java.util.Random(_seed)
    override def toString: String = "mma"
  }
  
  object Hgre extends GrEvoHeuristic {
    override val _population: Int = 100
    override val _length: Int = 9
    override val _maxChoice: Int = 7
    override val _tournamentSize = 5
    override val _generations = 10
    override val _recursionDepth = 10
    override val RNG: java.util.Random = new java.util.Random(_seed)
    override def toString: String = "gre"
  }

  object Hran extends RandomHeuristic {
    override val _iterations = 100
    override val _recursionDepth = 10
    override val RNG: java.util.Random = new java.util.Random(_seed)
    override def toString: String = "ran"
  }

  //////////////////////////////////////////////////////////////////////
  // Problem Description
  
 
  //////////////////////////////////////////////////////////////////////
  // Experiment Details


  def main(args: Array[String]): Unit = {
    import com.containant.casestudies.Framework
    println("\n-----------------------------")
    println("Case Study 1: Branin Function")
    println("Runs: " + _runs)
    
    val comparison =
      Framework.experiment[Branin](Hmma, Hgre, _runs, BraninModule, target)

    val reference =
      Framework.experiment[Branin](Hran, Hran, _runs, BraninModule, target)
    
    println("heuristic,min,mean,max,var")
    println(comparison.summary1)
    println(comparison.summary2)
    println(reference.summary1)
    println("p: " + comparison.pvalue)
    println()
  }
  
}
